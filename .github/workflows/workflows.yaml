name: 'Multi-Architecture Docker Build'
on:
  workflow_call:
    inputs:
      images:
        description: 'Name of images to build'
        required: true
        type: string
      acr-registry-url:
        description: 'The url of the ACR registry to fetch credentials from'
        required: false
        type: string
        default: 'tignis.azurecr.io'        
      push:
        description: 'Also push the image to the remote repository'
        required: false
        type: string
        default: 'true'
      docker-build-context:
        description: 'Build context for docker'
        required: false
        type: string
        default: '.'
      dockerfile:
        description: 'Name of the docker file to use'
        required: false
        type: string
        default: 'Dockerfile'
    secrets:
      acr-username:
        description: 'Username to use when logging into ACR'
        required: true
      acr-password:
        description: 'Password to use when logging into ACR'
        required: true
      pip-extra-index-url:
        description: 'The PIP_EXTRA_INDEX_URL for private pip packages'
        required: true
      GH_TOKEN:  # Renamed from GITHUB_TOKEN
        description: 'GitHub token for API access'
        required: true        
    outputs:
      tag:
        description: 'Final tag used for the multi-architecture docker image'
        value: ${{ jobs.docker-manifest.outputs.tag }}

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  docker-amd64:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.docker.outputs.tag }}
      digest: ${{ steps.digest.outputs.digest }}
      image: ${{ inputs.images }}
      tag-prefix: amd64-
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Build and Push docker image (AMD64)
        id: docker
        uses: tignis/docker-github-action@v2.3.1
        with:
          images: ${{ inputs.images }}
          acr-username: ${{ secrets.acr-username }}
          acr-password: ${{ secrets.acr-password }}
          acr-registry-url: ${{ inputs.acr-registry-url }}
          pip-extra-index-url: ${{ secrets.pip-extra-index-url }}
          push: ${{ inputs.push }}
          docker-build-context: ${{ inputs.docker-build-context }}
          dockerfile: ${{ inputs.dockerfile }}
          platforms: 'linux/amd64'
          tag-prefix: 'amd64-'
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
          

  docker-arm64:
    runs-on: [self-hosted, linux, ARM64]
    outputs:
      tag: ${{ steps.docker.outputs.tag }}
      digest: ${{ steps.digest.outputs.digest }}
      tag-prefix: arm64-
      image: ${{ inputs.images }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Build and Push docker image (ARM64)
        id: docker
        uses: tignis/docker-github-action@v2.3.1
        with:
          images: ${{ inputs.images }}
          acr-username: ${{ secrets.acr-username }}
          acr-password: ${{ secrets.acr-password }}
          acr-registry-url: ${{ inputs.acr-registry-url }}
          pip-extra-index-url: ${{ secrets.pip-extra-index-url }}
          push: ${{ inputs.push }}
          docker-build-context: ${{ inputs.docker-build-context }}
          dockerfile: ${{ inputs.dockerfile }}
          platforms: 'linux/arm64'
          tag-prefix: 'arm64-'
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}

  docker-manifest:
    needs: [docker-amd64, docker-arm64]
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.final.outputs.tag }}
    steps:
      - name: Login to ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.acr-registry-url }}
          username: ${{ secrets.acr-username }}
          password: ${{ secrets.acr-password }}
    
      - name: Extract clean tag
        id: clean-tag
        run: |
          AMD64_TAG=${{ needs.docker-amd64.outputs.tag }}
          CLEAN_TAG=${AMD64_TAG#*:amd64-}
          echo "value=${CLEAN_TAG}" >> $GITHUB_OUTPUT
    
      - name: Get image digests instead of tags
        id: digests
        run: |
          # Get the actual image digests for single-platform images
          AMD64_MANIFEST=$(docker manifest inspect ${{ needs.docker-amd64.outputs.tag }} --verbose)
          ARM64_MANIFEST=$(docker manifest inspect ${{ needs.docker-arm64.outputs.tag }} --verbose)
          
          # Extract the digest for the specific platform from manifest lists
          AMD64_DIGEST=$(echo "$AMD64_MANIFEST" | jq -r '.[] | select(.Descriptor.platform.architecture=="amd64") | .Descriptor.digest')
          ARM64_DIGEST=$(echo "$ARM64_MANIFEST" | jq -r '.[] | select(.Descriptor.platform.architecture=="arm64") | .Descriptor.digest')
          
          # If the above doesn't work (single platform images), get the manifest digest directly
          if [ -z "$AMD64_DIGEST" ] || [ "$AMD64_DIGEST" = "null" ]; then
            AMD64_DIGEST=$(docker manifest inspect ${{ needs.docker-amd64.outputs.tag }} | jq -r '.config.digest // .digest')
          fi
          
          if [ -z "$ARM64_DIGEST" ] || [ "$ARM64_DIGEST" = "null" ]; then
            ARM64_DIGEST=$(docker manifest inspect ${{ needs.docker-arm64.outputs.tag }} | jq -r '.config.digest // .digest')
          fi
          
          echo "amd64-digest=${AMD64_DIGEST}" >> $GITHUB_OUTPUT
          echo "arm64-digest=${ARM64_DIGEST}" >> $GITHUB_OUTPUT
          
          echo "AMD64 digest: ${AMD64_DIGEST}"
          echo "ARM64 digest: ${ARM64_DIGEST}"
    
      - name: Create multi-arch manifest from digests
        id: final
        run: |
          IMAGE=${{ inputs.images }}
          CLEAN_TAG=${{ steps.clean-tag.outputs.value }}
          FINAL_TAG="${IMAGE}:${CLEAN_TAG}"
          
          AMD64_DIGEST=${{ steps.digests.outputs.amd64-digest }}
          ARM64_DIGEST=${{ steps.digests.outputs.arm64-digest }}
          
          # Enable experimental features
          export DOCKER_CLI_EXPERIMENTAL=enabled
          
          echo "Creating manifest ${FINAL_TAG} from digests:"
          echo "  AMD64: ${IMAGE}@${AMD64_DIGEST}"
          echo "  ARM64: ${IMAGE}@${ARM64_DIGEST}"
          
          # Create manifest using digests instead of tags
          docker manifest create ${FINAL_TAG} \
            ${IMAGE}@${AMD64_DIGEST} \
            ${IMAGE}@${ARM64_DIGEST}
          
          # Add architecture annotations using digests
          docker manifest annotate ${FINAL_TAG} \
            ${IMAGE}@${AMD64_DIGEST} --os linux --arch amd64
          docker manifest annotate ${FINAL_TAG} \
            ${IMAGE}@${ARM64_DIGEST} --os linux --arch arm64
          
          # Push the manifest
          docker manifest push ${FINAL_TAG}
          
          echo "tag=${FINAL_TAG}" >> $GITHUB_OUTPUT
          echo "Multi-arch manifest created: ${FINAL_TAG}"
          
      - name: Report build status
        if: always()
        run: |
          echo "âœ… Docker multi-arch build completed successfully!"
          echo "Build status: success"
            
      - name: Workflow conclusion
        run: |
          echo "conclusion=success" >> $GITHUB_OUTPUT
        id: conclusion

  status-report:
    needs: [docker-manifest]
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ needs.docker-manifest.outputs.tag }}
    steps:
      - name: Mark build as complete
        if: always()
        run: |
          echo "Marking build as complete"
          echo "Build ID: ${{ github.run_id }}"
          echo "Repository: ${{ github.repository }}"
            
      - name: Report build summary
        run: |
          echo "âœ… Multi-architecture Docker build completed successfully!"
          echo "ðŸŽ¯ Final Result: ${{ needs.docker-manifest.outputs.tag }}"
          
  # This job serves as a final indicator that the workflow has completed successfully
  workflow-completed:
    needs: [status-report]
    runs-on: ubuntu-latest
    steps:
      - name: Final status
        run: |
          echo "âœ… All Docker build steps completed successfully!"
          echo "Build workflow completed at $(date)"
